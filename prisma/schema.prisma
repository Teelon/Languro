generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                    String                 @id @default(cuid())
  name                  String?
  email                 String?                @unique
  emailVerified         DateTime?
  image                 String?
  password              String?
  passwordResetToken    String?                @unique
  passwordResetTokenExp DateTime?
  accounts              Account[]
  sessions              Session[]
  feedback              ConjugationFeedback[]
  onboardingProfile     UserOnboardingProfile?
  onboardingProgress    OnboardingProgress?
  preferences           UserPreferences?

  // Learning system relations
  userLists      UserList[]
  masteryRecords Mastery[]
  drillAttempts  Attempt[]

  vocabulary     UserVocabulary[]
  readingProgress ReadingProgress[]
  
  // Writing practice relations
  writingPrompts     WritingPrompt[]
  writingSubmissions WritingSubmission[]
}

model UserPreferences {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Privacy & Data
  shareProgressWithFriends Boolean @default(true)
  showInSearch             Boolean @default(true)
  dataSharing              Boolean @default(true)
  activityVisibility       String  @default("public")

  // Communication Preferences
  emailDigestFrequency  String  @default("weekly")
  pushNotificationTime  String?
  doNotDisturbStart     String?
  doNotDisturbEnd       String?
  communicationLanguage String  @default("en")

  // Content & Features
  newContentAlerts      Boolean @default(true)
  recommendedLessons    Boolean @default(true)
  tipsTricks            Boolean @default(true)
  pronunciationFeedback Boolean @default(true)

  // Social & Community
  followNotifications   Boolean @default(true)
  commentNotifications  Boolean @default(true)
  leaderboardUpdates    Boolean @default(true)
  friendActivityUpdates Boolean @default(true)
  studyGroupInvites     Boolean @default(true)
  motivationalMessages  Boolean @default(true)
  weeklyProgressReports Boolean @default(true)

  // Security & General
  marketingEmails Boolean @default(true)
  newsletter      Boolean @default(true)
  surveyEmails    Boolean @default(true)
  securityAlerts  Boolean @default(true)

  updatedAt DateTime @updatedAt

  @@map("user_preferences")
}

model UserOnboardingProfile {
  id               String   @id @default(cuid())
  userId           String   @unique
  nativeLanguageId Int
  targetLanguageId Int
  cefrLevel        String   @db.VarChar(2)
  learningGoal     String[]
  dailyCommitment  Int
  interests        String[]
  completed        Boolean  @default(false)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  nativeLanguage Language @relation("NativeLanguage", fields: [nativeLanguageId], references: [id])
  targetLanguage Language @relation("TargetLanguage", fields: [targetLanguageId], references: [id])

  @@map("user_onboarding_profile")
}

model OnboardingProgress {
  id          String   @id @default(cuid())
  userId      String   @unique
  currentStep Int      @default(1)
  data        Json
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("onboarding_progress")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Language {
  id                  Int                     @id @default(autoincrement())
  name                String                  @db.VarChar(50)
  iso_code            String                  @unique @db.VarChar(5)
  pronouns            Pronoun[]
  tenses              Tense[]
  verb_translations   VerbTranslation[]
  contentItems        ContentItem[]
  userLists           UserList[]
  templatePacks       TemplatePack[]
  nativeLanguageUsers UserOnboardingProfile[] @relation("NativeLanguage")
  targetLanguageUsers UserOnboardingProfile[] @relation("TargetLanguage")
  userVocabulary      UserVocabulary[]
  
  // Writing practice relations
  writingPrompts      WritingPrompt[]

  @@map("languages")
}

model TenseCategory {
  id     Int     @id @default(autoincrement())
  name   String  @db.VarChar(50)
  tenses Tense[]

  @@map("tense_categories")
}

model Pronoun {
  id           Int           @id @default(autoincrement())
  language_id  Int
  code         String        @db.VarChar(10)
  label        String        @db.VarChar(50)
  conjugations Conjugation[]
  language     Language      @relation(fields: [language_id], references: [id], onDelete: Cascade)

  @@map("pronouns")
}

model VerbConcept {
  id                Int               @id @default(autoincrement())
  concept_name      String            @unique @db.VarChar(100)
  definition        String?
  verb_translations VerbTranslation[]

  @@map("verb_concepts")
}

model VerbTranslation {
  id           Int           @id @default(autoincrement())
  concept_id   Int?
  language_id  Int
  word         String        @db.VarChar(100)
  conjugations Conjugation[]
  contentItems ContentItem[]
  concept      VerbConcept?  @relation(fields: [concept_id], references: [id], onDelete: Cascade)
  language     Language      @relation(fields: [language_id], references: [id], onDelete: Cascade)

  @@unique([language_id, word], map: "uq_lang_word")
  @@map("verb_translations")
}

model Tense {
  id           Int            @id @default(autoincrement())
  language_id  Int?
  category_id  Int?
  tense_name   String         @db.VarChar(100)
  mood         String?        @default("Indicative") @db.VarChar(50)
  is_literary  Boolean?       @default(false)
  conjugations Conjugation[]
  category     TenseCategory? @relation(fields: [category_id], references: [id])
  language     Language?      @relation(fields: [language_id], references: [id], onDelete: Cascade)

  @@map("tenses")
}

model Conjugation {
  id                  Int                   @id @default(autoincrement())
  verb_translation_id Int?
  tense_id            Int?
  pronoun_id          Int?
  auxiliary_part      String?               @db.VarChar(50)
  root_part           String?               @db.VarChar(50)
  ending_part         String?               @db.VarChar(50)
  display_form        String                @db.VarChar(255)
  has_audio           Boolean?              @default(false)
  audio_file_key      String?               @db.VarChar(255)
  vote_score          Int?                  @default(0)
  is_flagged          Boolean?              @default(false)
  feedback            ConjugationFeedback[]
  pronoun             Pronoun?              @relation(fields: [pronoun_id], references: [id])
  tense               Tense?                @relation(fields: [tense_id], references: [id])
  verb_translation    VerbTranslation?      @relation(fields: [verb_translation_id], references: [id], onDelete: Cascade)

  @@unique([verb_translation_id, tense_id, pronoun_id], map: "uq_conjugation")
  @@index([display_form], map: "idx_conjugations_display_search")
  @@index([verb_translation_id, tense_id], map: "idx_conjugations_lookup")
  @@map("conjugations")
}

model ConjugationFeedback {
  id             Int              @id @default(autoincrement())
  conjugation_id Int?
  vote_type      FeedbackVoteType
  reason         String?
  ip_hash        String?          @db.VarChar(64)
  user_id        String? // Link to User
  status         FeedbackStatus?  @default(pending)
  created_at     DateTime?        @default(now())
  conjugation    Conjugation?     @relation(fields: [conjugation_id], references: [id], onDelete: Cascade)
  user           User?            @relation(fields: [user_id], references: [id], onDelete: SetNull)

  @@unique([conjugation_id, ip_hash], map: "uq_feedback_ip")
  @@map("conjugation_feedback")
}

enum FeedbackVoteType {
  up
  down

  @@map("feedback_vote_type")
}

enum FeedbackStatus {
  pending
  resolved
  ignored

  @@map("feedback_status")
}

// ============================================
// NEW: LEARNING SYSTEM TABLES
// ============================================

model ContentItem {
  id                String   @id @default(cuid())
  languageId        Int
  contentType       String
  verbTranslationId Int?
  data              Json?
  metadata          Json?
  createdAt         DateTime @default(now())

  language          Language           @relation(fields: [languageId], references: [id], onDelete: Cascade)
  verbTranslation   VerbTranslation?   @relation(fields: [verbTranslationId], references: [id], onDelete: Cascade)
  drillItems        DrillItem[]
  userListItems     UserListItem[]
  templatePackItems TemplatePackItem[]
  userVocabulary    UserVocabulary[]
  readingLesson     ReadingLesson?

  @@unique([languageId, contentType, verbTranslationId])
  @@index([contentType, languageId])
  @@index([languageId])
  @@index([verbTranslationId])
  @@map("content_items")
}

model ReadingLesson {
  id            String      @id @default(cuid())
  contentItemId String      @unique
  
  title         String
  content       String      @db.Text
  difficulty    String      // A1, B2 etc
  audioKey      String?     // R2 key
  alignment     Json?       // Word-level timestamps
  
  contentItem   ContentItem @relation(fields: [contentItemId], references: [id], onDelete: Cascade)
  progress      ReadingProgress[]

  @@map("reading_lessons")
}

model ReadingProgress {
  id              String        @id @default(cuid())
  userId          String
  readingLessonId String
  status          String        @default("started") // "started", "completed"
  completedAt     DateTime?
  
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  readingLesson   ReadingLesson @relation(fields: [readingLessonId], references: [id], onDelete: Cascade)

  @@unique([userId, readingLessonId])
  @@map("reading_progress")
}

// ============================================
// WRITING PRACTICE FEATURE
// ============================================

// Shared image pool - reduces Gemini API costs
model WritingImage {
  id          String   @id @default(cuid())
  imageUrl    String   // R2 public URL
  imageKey    String   // R2 storage key
  difficulty  String   @db.VarChar(2) // A1, A2, B1, B2, C1, C2
  topic       String?  // Optional category (travel, food, etc.)
  description String?  @db.Text // AI-generated description for validation
  usageCount  Int      @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  
  prompts     WritingPrompt[]
  
  @@index([difficulty, isActive])
  @@map("writing_images")
}

// Links user to a shared image for a writing prompt
model WritingPrompt {
  id          String   @id @default(cuid())
  userId      String
  imageId     String
  languageId  Int
  
  promptText  String   @db.Text // "Describe what you see..."
  createdAt   DateTime @default(now())
  
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  image       WritingImage  @relation(fields: [imageId], references: [id])
  language    Language      @relation(fields: [languageId], references: [id])
  submissions WritingSubmission[]
  
  @@index([userId])
  @@map("writing_prompts")
}

// User's writing submission with AI corrections
model WritingSubmission {
  id              String   @id @default(cuid())
  promptId        String
  userId          String
  
  inputType       String   // "typed" | "handwritten"
  originalInput   String?  @db.Text // Raw typed text
  handwritingKey  String?  // R2 key if handwritten image uploaded
  recognizedText  String?  @db.Text // OCR result from Gemini vision
  
  correctedText   String   @db.Text // Text with corrections applied
  corrections     Json     // Array of {original, corrected, explanation, explanationNative}
  overallFeedback Json     // {targetLanguage: "...", nativeLanguage: "..."}
  score           Float?   // Optional accuracy score (0-100)
  
  createdAt       DateTime @default(now())
  
  prompt          WritingPrompt @relation(fields: [promptId], references: [id], onDelete: Cascade)
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([promptId])
  @@map("writing_submissions")
}

model DrillItem {
  id             String @id @default(cuid())
  contentItemId  String
  drillType      String
  promptTemplate Json
  validationRule Json
  metadata       Json?

  contentItem    ContentItem @relation(fields: [contentItemId], references: [id], onDelete: Cascade)
  masteryRecords Mastery[]
  attempts       Attempt[]

  @@index([contentItemId, drillType])
  @@index([drillType])
  @@map("drill_items")
}

model UserList {
  id          String    @id @default(cuid())
  userId      String
  languageId  Int
  name        String    @db.VarChar(255)
  description String?
  isActive    Boolean   @default(true)
  isArchived  Boolean   @default(false)
  archivedAt  DateTime?
  sortOrder   Int?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user     User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  language Language       @relation(fields: [languageId], references: [id], onDelete: Restrict)
  items    UserListItem[]

  @@index([userId, languageId, isActive])
  @@map("user_lists")
}

model UserListItem {
  id            String @id @default(cuid())
  listId        String
  contentItemId String

  addedAt   DateTime @default(now())
  sortOrder Int?
  notes     String?
  context   String?  @db.Text // Store the sentence context where word was found

  list        UserList    @relation(fields: [listId], references: [id], onDelete: Cascade)
  contentItem ContentItem @relation(fields: [contentItemId], references: [id], onDelete: Cascade)

  @@unique([listId, contentItemId])
  @@index([listId])
  @@map("user_list_items")
}

model Mastery {
  id              String    @id @default(cuid())
  userId          String
  drillItemId     String
  score           Float     @default(0)
  correctStreak   Int       @default(0)
  longestStreak   Int       @default(0)
  seenCount       Int       @default(0)
  correctCount    Int       @default(0)
  currentInterval Int?
  nextReviewAt    DateTime?
  lastAttemptAt   DateTime?
  stage           String    @default("new")
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  drillItem DrillItem @relation(fields: [drillItemId], references: [id], onDelete: Cascade)

  @@unique([userId, drillItemId])
  @@index([userId, nextReviewAt])
  @@index([userId, score])
  @@index([userId, stage])
  @@index([userId, nextReviewAt, stage])
  @@map("mastery")
}

model Attempt {
  id               String   @id @default(cuid())
  userId           String
  drillItemId      String
  sessionId        String?
  userInput        String?
  selectedOptionId String?
  isCorrect        Boolean
  errorType        String?
  errorDetails     Json?
  timeSpentMs      Int?
  hintsUsed        Int      @default(0)
  promptData       Json?
  attemptedAt      DateTime @default(now())

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  drillItem DrillItem @relation(fields: [drillItemId], references: [id], onDelete: Cascade)

  @@index([userId, attemptedAt])
  @@index([drillItemId])
  @@index([userId, isCorrect, attemptedAt])
  @@index([sessionId])
  @@map("attempts")
}

model TemplatePack {
  id         String @id @default(cuid())
  languageId Int // Foreign key to Language table

  name        String  @db.VarChar(255)
  description String?
  category    String // 'verbs', 'vocabulary', 'phrases', 'mixed'
  cefrLevel   String  @db.VarChar(2) // 'A1', 'A2', 'B1', 'B2', 'C1', 'C2'
  isPublic    Boolean @default(true)
  sortOrder   Int?

  createdAt DateTime @default(now())

  language Language           @relation(fields: [languageId], references: [id], onDelete: Restrict)
  items    TemplatePackItem[]

  @@index([languageId, category, cefrLevel])
  @@map("template_packs")
}

model TemplatePackItem {
  id            String @id @default(cuid())
  packId        String
  contentItemId String
  sortOrder     Int

  pack        TemplatePack @relation(fields: [packId], references: [id], onDelete: Cascade)
  contentItem ContentItem  @relation(fields: [contentItemId], references: [id], onDelete: Cascade)

  @@index([packId, sortOrder])
  @@map("template_pack_items")
}

model UserVocabulary {
  id             String    @id @default(cuid())
  userId         String
  word           String    @db.VarChar(100)
  languageId     Int
  contentItemId  String?
  
  firstSeenAt    DateTime  @default(now())
  lastSeenAt     DateTime  @default(now())
  encounterCount Int       @default(1)
  
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  language       Language     @relation(fields: [languageId], references: [id], onDelete: Cascade)
  contentItem    ContentItem? @relation(fields: [contentItemId], references: [id], onDelete: SetNull)

  @@unique([userId, languageId, word])
  @@index([userId, lastSeenAt])
  @@map("user_vocabulary")
}

// Database View for full conjugation data (read-only)
model VwFullConjugation {
  // Composite key for Prisma (view has no real PK)
  conjugationId     Int      @id @map("conjugation_id")
  verbTranslationId Int      @map("verb_translation_id")
  infinitive        String
  language          String
  concept           String?
  definition        String?
  tenseId           Int      @map("tense_id")
  tenseName         String   @map("tense_name")
  mood              String?
  pronounId         Int      @map("pronoun_id")
  pronoun           String
  text              String
  auxiliary         String?
  root              String?
  ending            String?
  hasAudio          Boolean  @map("has_audio")
  audioFileKey      String?  @map("audio_file_key")
  voteScore         Int      @map("vote_score")

  @@map("vw_full_conjugations")
}

model HandwritingSession {
  id        String   @id @default(cuid())
  status    String   @default("pending") // pending, uploaded, consumed
  imageUrl  String?  // R2 URL
  imageKey  String?  // R2 Key
  createdAt DateTime @default(now())
  expiresAt DateTime

  @@map("handwriting_sessions")
}
